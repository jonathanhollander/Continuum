import { getStored, setStored } from "$lib/stores/persistence";
import { type SyncManager, registerSync, getRegistry } from "$lib/services/sync.svelte";

const TEST_REGISTRY_KEY = "continuum_test_registry";

type TestRegistry = {
    [moduleId: string]: string[];
};

class TestDataFactoryService {
    private _initialized = false;

    ensureInitialized() {
        if (this._initialized) return;

        // Assets
        registerSync("assets", "assets");
        registerSync("financial_accounts", "financial_accounts");
        // Subscriptions
        registerSync("subscriptions", "subscriptions");
        // Calendar
        registerSync("calendar_events", "calendar_events");
        // Letters
        registerSync("letters", "letters");
        // Documents (Default Vault)
        registerSync("documents", "documents");

        this._initialized = true;
        console.log("[FactoryService] Initialized sync managers.");
    }

    async generate() {
        console.log("[FactoryService] Generate REQUESTED");
        this.ensureInitialized();

        const registry = getStored<TestRegistry>(TEST_REGISTRY_KEY, {});
        const modules = ["assets", "financial_accounts", "subscriptions", "calendar_events", "letters", "documents"];

        for (const mod of modules) {
            let syncKey = mod;

            const sync = getRegistry()[syncKey];
            console.log(`[FactoryService] Mod: ${mod}, Key: ${syncKey}, SyncFound: ${!!sync}`);

            if (sync) {
                const newIds = [];
                const count = Math.floor(Math.random() * 3) + 1;

                for (let i = 0; i < count; i++) {
                    const fakeItem = this.createFakeItem(mod);
                    try {
                        const created = await sync.create(fakeItem);
                        if (created && created.id) {
                            newIds.push(String(created.id));
                        }
                    } catch (e) {
                        console.error(`[FactoryService] Failed to create for ${mod}`, e);
                    }
                }
                registry[mod] = [...(registry[mod] || []), ...newIds];
            }
        }

        setStored(TEST_REGISTRY_KEY, registry);
        return registry;
    }

    async purge() {
        this.ensureInitialized();
        const registry = getStored<TestRegistry>(TEST_REGISTRY_KEY, {});
        let deletedCount = 0;

        for (const [mod, ids] of Object.entries(registry)) {
            let syncKey = mod;

            const sync = getRegistry()[syncKey];
            if (sync) {
                for (const id of ids) {
                    try {
                        await sync.delete(id);
                        deletedCount++;
                    } catch (e) {
                        console.warn(`[FactoryService] Failed delete ${id}`, e);
                    }
                }
            }
        }

        setStored(TEST_REGISTRY_KEY, {});
        return deletedCount;
    }

    getRegistry() {
        return getStored<TestRegistry>(TEST_REGISTRY_KEY, {});
    }

    isTestId(mod: string, id: string) {
        const registry = getStored<TestRegistry>(TEST_REGISTRY_KEY, {});
        return registry[mod]?.includes(String(id)) || false;
    }

    private createFakeItem(moduleType: string): any {
        const r = (n: number) => Math.floor(Math.random() * n);

        switch (moduleType) {
            case "assets":
                return {
                    name: `Test Asset #${r(999)}`,
                    type: "Valuable",
                    location: "Test Vault",
                    valuation: (r(100) + 1) * 1000,
                    status: "Owned",
                    ownershipDetails: "Sole",
                    documents: "None",
                    notes: "Generated by Test Suite"
                };
            case "subscriptions":
                return {
                    name: `Test Service #${r(999)}`,
                    cost: (r(20) + 5),
                    cycle: "Monthly",
                    difficulty: "Easy",
                    paymentMethod: "Test Card"
                };
            case "calendar_events":
                return {
                    title: `Test Event #${r(999)}`,
                    date: new Date(Date.now() + 86400000 * r(30)).toISOString(),
                    type: "event",
                    recurrence: "None"
                };
            case "letters":
                return {
                    title: `Test Letter #${r(999)}`,
                    recipient_name: "Test User",
                    content: "This is a test letter generated by the validation suite.",
                    status: "draft",
                    release_condition: "death"
                };
            case "financial_accounts":
                return {
                    institution: `Test Bank #${r(99)}`,
                    account_type: ["checking", "savings", "investment"][r(3)],
                    holder_name: "Test User",
                    balance_estimate: r(50000)
                };
            case "documents":
                return {
                    title: `Test Doc #${r(999)}`,
                    name: `Test Doc #${r(999)}`,
                    category: ["will", "trust", "deed", "insurance"][r(4)],
                    location: "Digital Vault",
                    status: "verified"
                };
            default:
                return { name: "Test Item" };
        }
    }
}

export const testDataFactory = new TestDataFactoryService();

